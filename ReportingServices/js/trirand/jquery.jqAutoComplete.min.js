; (function($, window, document, undefined) {
    "use strict";
    var pluginName = 'jqAutoComplete',
		defaults = {
		    id: "",
		    dataUrl: "",
		    delay: 300,
            minLength: 1,
		    width: 100,
		    height: 100,
		    dropDownWidth: null,
		    enabled: true,
		    items: [],
		    tabIndex: 0,
            loadingImageUrl: "",
		    initialText: "",
		    itemTemplateID: "",
		    headerTemplateID: "",
		    footerTemplateID: "",
		    filter: "none",
		    onShow: null,
		    onHide: null,
		    onSelect: null,
		    onMouseOver: null,
		    onMouseOut: null,
		    onInitialized: null,
		    onKeyDown: null
		};

    function AutoComplete(element, options) {
        this.self = $(element);
        this.options = $.extend({}, defaults, options);

        if (this.options.dropDownWidth === null) {
            this.options.dropDownWidth = this.options.width;
        }

        this.toggleActive = false;
        this.autoCompleteVisible = false;
        this.selectedIndex = -1;
        this.keyboardIndex = -1;
        this.cancelChange = false;
        this.ajaxObject = null;
        this.controlEditor = (this.self[0].tagName == "INPUT") ? true : false;

        $(element).prop("autocomplete", this);

        this.getInitialText();

        this.renderToLevelSpan();
        //if (this.options.items.length > 0) {
        //    this.renderItems(this.options.items);
        //}

        this.renderHiddenValueField();
        this.attachEvents();

        if (this.selectedIndex > -1) {
            this.keyboardIndex = this.selectedIndex;
            var item = this.getItemByIndex(this.selectedIndex);
            item.find("tr:eq(0)").addClass("ui-state-highlight");
        }

        this.serializeSelectedValue();

        if (this.options.onInitialized) {
            this.options.onInitialized(this);
        }
    }

    AutoComplete.prototype.renderToLevelSpan = function() {
        var sb = [];
        var o = this.options;
        var spanStart = "<span id='" + o.id + "_placeholder' class='ui-jqautocomplete-placeholder'>";

        if (!this.controlEditor) {
            sb.push(spanStart);
            sb.push("<input type='text' style='width:" + o.width + "px;' class='ui-widget ui-jqautocomplete-input' value='" + this.initialText + "'></input>");
            sb.push("</span>");
            var htmlElement = $(sb.join(""));
            this.self.append(htmlElement);
        }
        else {
            //this.self.wrap(spanStart + "</span>");
            this.self.addClass("ui-jqautocomplete-input");
        }        
    };

    AutoComplete.prototype.renderItems = function(json) {
        var that = this;
        var sb = [];

        if (this.getDropDownElement().length > 0) {
            this.getDropDownElement().remove();
        }

        sb.push("<div id=" + this.options.id + "_autoCompleteWrapper class='ui-jqautocomplete-dropdown-wrapper ui-widget ui-widget-content ui-corner-all'");
        sb.push(">");

        if (this.options.headerTemplateID) {
            sb.push("<div id=" + this.options.id + "_autoCompleteHeader>");
            sb.push(this.renderTemplate(this.options.headerTemplateID));
            sb.push("</div>");
        }

        sb.push("<div id=" + this.options.id + "_autoComplete class='ui-jqautocomplete-dropdown'");
        sb.push(" style='");
        sb.push("width:" + this.options.dropDownWidth + "px;");
        if (this.options.height !== 100) {
            sb.push("height:" + this.options.height + "px;");
        }
        sb.push("'>");

        sb.push("<ul class='ui-helper-reset' style='width:" + this.options.dropDownWidth + "px;");
        if (this.options.height !== 100) {
            sb.push("height:" + this.options.height + "px;");
        }
        sb.push("'>");
        sb.push("</ul>");
        sb.push("</div>");

        if (this.options.footerTemplateID) {
            sb.push("<div id=" + this.options.id + "_autoCompleteFooter>");
            sb.push(this.renderTemplate(this.options.footerTemplateID));
            sb.push("</div>");
        }

        sb.push("</div>");

        var htmlElement = $(sb.join(""));
        this.parentElement = htmlElement.find("ul:eq(0)");

        $.each(json, function(index, options) {
            if (options.selected) {
                this.selectedIndex = index;
            }
            options.index = index;
            if (options.value === undefined) {
                options.value = options.text;
            }
            options.enabled = (options.enabled === undefined) ? true : false;

            that.renderItem(options, that.parentElement);
        });

        if (this.selectedIndex === -1 && json.length > 0) {
            this.selectedIndex = 0;
        }

        $("body").append(htmlElement);
    };

    AutoComplete.prototype.renderItem = function (json, parentElement) {
        var templateID = null;
        var sb = [];
        var text = json.text;
        var disabledCss = "";

        if (this.options.itemTemplateID) {
            templateID = this.options.itemTemplateID;
        }
        if (json.itemTemplateID) {
            templateID = json.itemTemplateID;
        }
        if (templateID) {
            text = this.renderTemplate(templateID, json);
        }
        if (!json.enabled) {
            disabledCss = "ui-state-disabled";
        }

        sb.push("<li class='ui-jqautocomplete-item'>");
        sb.push("<a onfocus='this.blur();'>");
        sb.push("<table cellpadding=0 cellspacing=0 style='width:100%;' class='ui-helper-reset'>");
        sb.push("<tr>");
        if (json.imageUrl) {
            sb.push("<td valign=middle style='width:21px;text-align:center;'><img class='ui-jqautocomplete-item-image' src='" + json.imageUrl + "' /></td>");
        }
        sb.push("<td valign=middle style='width:100%;' class='ui-corner-all'>");
        sb.push("<span class='ui-jqautocomplete-item-text " + disabledCss + "'>" + text + "</span>");
        sb.push("</td>");
        sb.push("</tr></table></a>");
        sb.push("</li>");

        var newItem = $(sb.join(""));
        newItem.data("options", json);

        parentElement.append(newItem);
    };

    AutoComplete.prototype.renderTemplate = function(templateID, json) {
        if (!$.isFunction($.tmpl)) {
            alert("You have specified using templates with jqAutoComplete, but the jQuery template library javascript is not referenced in the HTML.");
            return;
        }
        if ($("#" + templateID).length === 0) {
            alert("You have not specified a jQuery template with ID " + templateID + " that is not defined on the page");
            return;
        }

        if (json) {
            return $("#" + templateID).tmpl(json).clone().wrap('<div></div>').parent().html();
        }

        return $("#" + templateID).tmpl().clone().wrap('<div></div>').parent().html();
    };

    AutoComplete.prototype.renderHiddenValueField = function() {
        var selectedID = this.getSelectedValueHiddenID();
        //this.getTopLevelSpan().remove("#" + selectedID).append("<input type='hidden' id='" + selectedID + "' name='" + selectedID + "' />");
        this.getInputElement().after("<input type='hidden' id='" + selectedID + "' name='" + selectedID + "' />");
    };

    AutoComplete.prototype.getInitialText = function() {
        var that = this;
        this.initialText = "";
        if (this.options.items.length > 0) {
            this.initialText = this.options.items[0].text;
        }
        $.each(this.options.items, function(index, options) {
            if (options.selected) {
                that.initialText = options.text;
            }
        });
    };

    AutoComplete.prototype.showDropDown = function() {
        if (this.options.onShow) {
            this.options.onShow();
        }

        this.autoCompleteVisible = true;
        var autoComplete = this.getDropDownElement();
        var input = this.getInputElement();
        var offset = input.offset();

        autoComplete.css({
            top: offset.top + input.outerHeight(),
            left: offset.left
        }).slideDown(120);

        if (this.selectedIndex > -1) {
            this.ensureVisible(this.getItemByIndex(this.selectedIndex));
        }
    };

    AutoComplete.prototype.showLoadingImage = function () {
        this.getInputElement().css( { background: "url('" + this.options.loadingImageUrl + "') no-repeat right center" });        
    };

    AutoComplete.prototype.hideLoadingImage = function () {
        this.getInputElement().css({ background: "" });
    };

    AutoComplete.prototype.hideDropDown = function() {
        if (this.options.onHide) {
            this.options.onHide();
        }

        this.autoCompleteVisible = false;
        var autoComplete = this.getDropDownElement();
        autoComplete.slideUp(120);
    };

    AutoComplete.prototype.toggleDropDown = function() {
        if (this.autoCompleteVisible) {
            this.hideDropDown();
        } else {
            this.showDropDown();
        }
    };

    AutoComplete.prototype.handleClick = function(event) {
        if (this.options.enabled) {
            this.getInputElement().focus();
            this.toggleDropDown();
            event.preventDefault();
            return false;
        }
    };

    // need this to cancel blur from firing on scrollbar click
    AutoComplete.prototype.handleDropDownMouseDown = function(event) {
        event.preventDefault();
        return false;
    };

    // need this to cancel blur from firing in IE - hack
    AutoComplete.prototype.handleDropDownFocus = function(event) {
        this.getInputElement.focus();
    };

    AutoComplete.prototype.handleKeyDown = function(event) {
        if (this.options.onKeyDown) {
            var result = this.options.onKeyDown(this, event);
            if (result === false) {
                return;
            }
        }

        switch (event.keyCode) {
            case 40:
                var nextIndex = this.getNextActiveIndex(this.keyboardIndex);
                var item = this.getItemByIndex(nextIndex);
                this.cancelChange = true;
                this.select(item);
                event.preventDefault();
                break;
            case 38:
                var prevIndex = this.getPrevActiveIndex(this.keyboardIndex);
                var item = this.getItemByIndex(prevIndex);
                this.cancelChange = true;
                this.select(item);
                event.preventDefault();
                break;
            case 27:
                if (this.autoCompleteVisible) {
                    this.hideDropDown();
                }
                break;
            case 13:
                if (this.autoCompleteVisible) {
                    this.hideDropDown();
                }
                event.preventDefault();
                break;

        }
    };

    AutoComplete.prototype.getNextActiveIndex = function(index) {
        var originalIndex = index;
        while (index < this.getItemCount() - 1) {
            index++;
            var item = this.getItemByIndex(index);
            var options = this.getItemOptions(item);
            if (options.enabled && $(item).css("display") != "none") {
                return index;
            }
        }

        return originalIndex;
    };

    AutoComplete.prototype.getPrevActiveIndex = function(index) {
    var originalIndex = index;
        while (index > 0) {
            index--;
            var item = this.getItemByIndex(index);
            var options = this.getItemOptions(item);
            if (options.enabled && $(item).css("display") != "none") {
                return index;
            }
        }
        return originalIndex;
    };

    AutoComplete.prototype.handleFocus = function() {
        this.closeActive = false;
    };

    AutoComplete.prototype.handleBlur = function() {
        var that = this;
        this.closeActive = true;
        window.setTimeout(
			function() {
			    if (that.closeActive) {
			        that.hideDropDown();
			        that.closeActive = false;
			    }
			},
		100);
    };

    AutoComplete.prototype.handleChange = function (e) {
        var specialChars = [39, 37, 40, 38, 16, 17, 18, 20, 13, 36, 35, 45];
        if ($.inArray(e.keyCode, specialChars) >= 0) return;

        if (this.cancelChange) {
            this.cancelChange = false;
            return;
        }
      
        if (this.ajaxObject) {
            this.ajaxObject.abort();
        }

        this.showLoadingImage();
        this.ajaxObject = $.ajax({
            url: this.options.dataUrl + "&term=" + encodeURIComponent(this.getText()),
            context: this
        }).done(function (json) {
            this.ajaxObject = null;
            this.hideLoadingImage();
            this.options.items = $.parseJSON(json);
            this.renderItems(this.options.items);
            this.showDropDown();
            this.attachDropDownEvents();
        });

        var item = this.getItemByText(this.getText());
        if (item != null) {
            var options = this.getItemOptions(item);
            if (this.selectedIndex != options.index && options.enabled) {
                this.select(item);
            }
        }
        else {
            this.getDropDownElement().find(".ui-state-highlight")
                                    .removeClass("ui-state-highlight")
                                    .addClass("ui-state-hover");
            this.selectedIndex = -1;
        }
    };

    AutoComplete.prototype.filterItems = function() {
        var text = this.getText();
        var that = this;
        var items = this.getDropDownElement().find(".ui-jqautocomplete-item");

        $.each(items, function(index, item) {
            var itemText = that.getItemOptions($(item)).text;
            if (that.options.filter == "contains") {
                (itemText.indexOf(text) == -1)
                   ? $(item).css("display", "none")
                   : $(item).css("display", "block");
            }
            if (that.options.filter == "startswith") {
                (itemText.indexOf(text) == 0)
                   ? $(item).css("display", "block")
                   : $(item).css("display", "none");
            }

        });
    }

    AutoComplete.prototype.handleDropDownMouseOver = function(event) {
        var target = $(event.target);
        var parentLi = this.getItemParentLiElement(target);
        var options = this.getItemOptions(parentLi);

        if (options && options.enabled) {
            parentLi.find("tr:eq(0)").addClass("ui-state-hover");

            if (this.options.onMouseOver) {
                var item = this.getItemParentLiElement(target);
                this.options.onMouseOver(item, event);
            }
        }
    };

    AutoComplete.prototype.handleDropDownMouseOut = function(event) {
        var target = $(event.target);
        var parentLi = this.getItemParentLiElement(target);
        var options = this.getItemOptions(parentLi);

        if (options && options.enabled) {
            target.parents("tr:eq(0)").removeClass("ui-state-hover");

            if (this.options.onMouseOut) {
                var item = this.getItemParentLiElement(target);
                this.options.onMouseOut(item, event);
            }
        }
    };

    AutoComplete.prototype.handleDropDownClick = function(event) {
        var target = $(event.target);
        var item = this.getItemParentLiElement(target);
        var options = this.getItemOptions(item);

        if (item && options && options.enabled) {
            if (this.options.onSelect) {
                item = this.getItemParentLiElement(target);
                var result = this.options.onSelect(item, event);
                if (result === false) {
                    return;
                }
            }
            this.selectedIndex = options.index;
            this.select(item);
            this.hideDropDown();
            this.serializeSelectedValue();
        }
    };

    AutoComplete.prototype.getItemOptions = function(target) {
        return this.getItemParentLiElement(target).data("options");
    };

    AutoComplete.prototype.getItemParentLiElement = function(target) {
        return target.hasClass("ui-jqautocomplete-item") ? target : target.parents("li:eq(0)");
    };

    AutoComplete.prototype.getItemTextElement = function(target) {
        return this.getItemParentLiElement(target).find(".ui-jqautocomplete-item-text");
    };

    AutoComplete.prototype.getDropDownElement = function() {
        return $("#" + this.options.id + "_autoCompleteWrapper");
    };

    AutoComplete.prototype.getDropDownItemsElement = function() {
        return $("#" + this.options.id + "_autoComplete");
    };

    AutoComplete.prototype.getDropDownHeaderElement = function() {
        return $("#" + this.options.id + "_autoCompleteHeader");
    };

    AutoComplete.prototype.getDropDownFooterElement = function() {
        return $("#" + this.options.id + "_autoCompleteFooter");
    };

    AutoComplete.prototype.getTopLevelSpan = function() {
        return $("#" + this.options.id + "_placeholder");
    };

    AutoComplete.prototype.getInputElement = function () {
        return this.controlEditor
            ? this.self
            : this.getTopLevelSpan().find(".ui-jqautocomplete-input");
    };

    AutoComplete.prototype.getSelectedValueHiddenID = function() {
        return this.options.id + "_selectedValue";
    };

    AutoComplete.prototype.serializeSelectedValue = function() {
        var item = this.getItemByIndex(this.selectedIndex);
        if (item) {
            var options = this.getItemOptions(item);
            this.getInputElement().attr("value", options.text);
            this.getInputElement().trigger("change");
            $("#" + this.getSelectedValueHiddenID()).val(options.text);
        }
    };

    $.fn[pluginName] = function(options) {
        return this.each(function() {
            if (!$.data(this, 'plugin_' + pluginName)) {
                $.data(this, 'plugin_' + pluginName, new AutoComplete(this, options));
            }
        });
    };

    AutoComplete.prototype.attachEvents = function() {
        //var span = this.getTopLevelSpan();
        //span.bind('click', this.executeInContext(this, this.handleClick));
        //span.bind('keydown', this.executeInContext(this, this.handleKeyDown));

        var input = this.getInputElement();
        input.bind('focus', this.executeInContext(this, this.handleFocus));
        input.bind('blur', this.executeInContext(this, this.handleBlur));
        input.bind('keyup', this.executeInContext(this, this.handleChange));       
    };

    AutoComplete.prototype.attachDropDownEvents = function () {
        var dropDown = this.getDropDownElement();
        dropDown.on('mouseover', this.executeInContext(this, this.handleDropDownMouseOver));
        dropDown.on('mouseout', this.executeInContext(this, this.handleDropDownMouseOut));
        dropDown.on('click', this.executeInContext(this, this.handleDropDownClick));
        dropDown.on('mousedown', this.executeInContext(this, this.handleDropDownMouseDown));
        dropDown.on('focus', this.executeInContext(this, this.handleDropDownFocus));

        var autoCompleteItems = this.getDropDownItemsElement();
        autoCompleteItems.bind('focus', this.executeInContext(this, this.handleDropDownFocus));
    }

    AutoComplete.prototype.executeInContext = function(context, func) {
        return function() {
            func.apply(context, arguments);
        };
    };

    // Public API

    AutoComplete.prototype.getItemByText = function(text) {
        var that = this;
        that.resultItem = null;
        var items = this.getDropDownElement().find(".ui-jqautocomplete-item");
        $.each(items, function(index, item) {
            if (that.getItemOptions($(item)).text == text) {
                that.resultItem = $(item);
                return false;
            }
        });

        return that.resultItem;
    };

    AutoComplete.prototype.getItemByValue = function(value) {
        var that = this;
        that.resultItem = null;
        var items = this.getDropDownElement().find(".ui-jqautocomplete-item");
        $.each(items, function(index, item) {
            if (that.getItemOptions($(item)).value == value) {
                that.resultItem = $(item);
                return false;
            }
        });

        return that.resultItem;
    };

    AutoComplete.prototype.getSelectedValue = function() {
        var id = this.getSelectedValueHiddenID();
        return $("#" + id).val();
    }

    AutoComplete.prototype.getSelectedIndex = function() {
        return this.selectedIndex;
    };

    AutoComplete.prototype.getText = function() {
        return this.getInputElement().prop("value");
    };

    AutoComplete.prototype.getItemByIndex = function(index) {
        var item = this.getDropDownElement().find(".ui-jqautocomplete-item:eq(" + index + ")");
        return item.length == 0 ? null : item;
    };

    AutoComplete.prototype.getItemCount = function() {
        return this.getDropDownElement().find("li").length;
    };

    AutoComplete.prototype.select = function (item) {
        if (item) {
            var options = this.getItemOptions(item);
            console.log(this.getInputElement().val());
            this.getInputElement().val(options.text);

            this.unSelectAllItems();
            item.find("tr:eq(0)").addClass("ui-state-highlight");

            this.selectedIndex = this.keyboardIndex = options.index;

            this.serializeSelectedValue();
            this.ensureVisible(item);
        }
    };

    AutoComplete.prototype.unSelectAllItems = function() {
        this.getDropDownElement().find(".ui-state-highlight").removeClass("ui-state-highlight");
        this.getDropDownElement().find(".ui-state-hover").removeClass("ui-state-hover");
        this.selectedIndex = -1;
    };

    AutoComplete.prototype.ensureVisible = function(item) {
        item.scrollIntoView();
    };

    AutoComplete.prototype.enableItem = function(item) {
        this.getItemOptions(item).enabled = true;
        this.getItemTextElement(item).removeClass("ui-state-disabled");
    };

    AutoComplete.prototype.disableItem = function(item) {
        this.getItemOptions(item).enabled = false;
        this.getItemTextElement(item).addClass("ui-state-disabled");
    };

    AutoComplete.prototype.enable = function() {
        this.options.enabled = true;
        this.getInputElement().removeClass("ui-state-disabled");
    };

    AutoComplete.prototype.disable = function() {
        this.options.enabled = false;
        this.getInputElement().addClass("ui-state-disabled");
    };


    $.fn.getAutoCompleteInstance = function() {
        return $(this).prop("autocomplete");
    };

})(jQuery, window, document);


(function($) {
    var converter = {
        vertical: { x: false, y: true },
        horizontal: { x: true, y: false },
        both: { x: true, y: true },
        x: { x: true, y: false },
        y: { x: false, y: true }
    };

    var settings = {
        duration: "fast",
        direction: "both"
    };

    var rootrx = /^(?:html)$/i;

    // gets border dimensions
    var borders = function(domElement, styles) {
        styles = styles || (document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(domElement, null) : domElement.currentStyle);
        var px = document.defaultView && document.defaultView.getComputedStyle ? true : false;
        var b = {
            top: (parseFloat(px ? styles.borderTopWidth : $.css(domElement, "borderTopWidth")) || 0),
            left: (parseFloat(px ? styles.borderLeftWidth : $.css(domElement, "borderLeftWidth")) || 0),
            bottom: (parseFloat(px ? styles.borderBottomWidth : $.css(domElement, "borderBottomWidth")) || 0),
            right: (parseFloat(px ? styles.borderRightWidth : $.css(domElement, "borderRightWidth")) || 0)
        };
        return {
            top: b.top,
            left: b.left,
            bottom: b.bottom,
            right: b.right,
            vertical: b.top + b.bottom,
            horizontal: b.left + b.right
        };
    };

    var dimensions = function($element) {
        var win = $(window);
        var isRoot = rootrx.test($element[0].nodeName);
        return {
            border: isRoot ? { top: 0, left: 0, bottom: 0, right: 0} : borders($element[0]),
            scroll: {
                top: (isRoot ? win : $element).scrollTop(),
                left: (isRoot ? win : $element).scrollLeft()
            },
            scrollbar: {
                right: isRoot ? 0 : $element.innerWidth() - $element[0].clientWidth,
                bottom: isRoot ? 0 : $element.innerHeight() - $element[0].clientHeight
            },
            rect: (function() {
                var r = $element[0].getBoundingClientRect();
                return {
                    top: isRoot ? 0 : r.top,
                    left: isRoot ? 0 : r.left,
                    bottom: isRoot ? $element[0].clientHeight : r.bottom,
                    right: isRoot ? $element[0].clientWidth : r.right
                };
            })()
        };
    };

    $.fn.extend({
        scrollIntoView: function(options) {
            /// <summary>Scrolls the first element in the set into view by scrolling its closest scrollable parent.</summary>
            /// <param name="options" type="Object">Additional options that can configure scrolling:
            ///        duration (default: "fast") - jQuery animation speed (can be a duration string or number of milliseconds)
            ///        direction (default: "both") - select possible scrollings ("vertical" or "y", "horizontal" or "x", "both")
            ///        complete (default: none) - a function to call when scrolling completes (called in context of the DOM element being scrolled)
            /// </param>
            /// <return type="jQuery">Returns the same jQuery set that this function was run on.</return>

            options = $.extend({}, settings, options);
            options.direction = converter[typeof (options.direction) === "string" && options.direction.toLowerCase()] || converter.both;

            var dirStr = "";
            if (options.direction.x === true) dirStr = "horizontal";
            if (options.direction.y === true) dirStr = dirStr ? "both" : "vertical";

            var el = this.eq(0);
            var scroller = el.closest(":scrollable(" + dirStr + ")");

            // check if there's anything to scroll in the first place
            if (scroller.length > 0) {
                scroller = scroller.eq(0);

                var dim = {
                    e: dimensions(el),
                    s: dimensions(scroller)
                };

                var rel = {
                    top: dim.e.rect.top - (dim.s.rect.top + dim.s.border.top),
                    bottom: dim.s.rect.bottom - dim.s.border.bottom - dim.s.scrollbar.bottom - dim.e.rect.bottom,
                    left: dim.e.rect.left - (dim.s.rect.left + dim.s.border.left),
                    right: dim.s.rect.right - dim.s.border.right - dim.s.scrollbar.right - dim.e.rect.right
                };

                var animOptions = {};

                // vertical scroll
                if (options.direction.y === true) {
                    if (rel.top < 0) {
                        animOptions.scrollTop = dim.s.scroll.top + rel.top;
                    }
                    else if (rel.top > 0 && rel.bottom < 0) {
                        animOptions.scrollTop = dim.s.scroll.top + Math.min(rel.top, -rel.bottom);
                    }
                }

                // horizontal scroll
                if (options.direction.x === true) {
                    if (rel.left < 0) {
                        animOptions.scrollLeft = dim.s.scroll.left + rel.left;
                    }
                    else if (rel.left > 0 && rel.right < 0) {
                        animOptions.scrollLeft = dim.s.scroll.left + Math.min(rel.left, -rel.right);
                    }
                }

                // scroll if needed
                if (!$.isEmptyObject(animOptions)) {
                    if (rootrx.test(scroller[0].nodeName)) {
                        scroller = $("html,body");
                    }
                    scroller
                        .animate(animOptions, options.duration)
                        .eq(0) // we want function to be called just once (ref. "html,body")
                        .queue(function(next) {
                            $.isFunction(options.complete) && options.complete.call(scroller[0]);
                            next();
                        });
                }
                else {
                    // when there's nothing to scroll, just call the "complete" function
                    $.isFunction(options.complete) && options.complete.call(scroller[0]);
                }
            }

            // return set back
            return this;
        }
    });

    var scrollValue = {
        auto: true,
        scroll: true,
        visible: false,
        hidden: false
    };

    $.extend($.expr[":"], {
        scrollable: function(element, index, meta, stack) {
            var direction = converter[typeof (meta[3]) === "string" && meta[3].toLowerCase()] || converter.both;
            var styles = (document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(element, null) : element.currentStyle);
            var overflow = {
                x: scrollValue[styles.overflowX.toLowerCase()] || false,
                y: scrollValue[styles.overflowY.toLowerCase()] || false,
                isRoot: rootrx.test(element.nodeName)
            };

            // check if completely unscrollable (exclude HTML element because it's special)
            if (!overflow.x && !overflow.y && !overflow.isRoot) {
                return false;
            }

            var size = {
                height: {
                    scroll: element.scrollHeight,
                    client: element.clientHeight
                },
                width: {
                    scroll: element.scrollWidth,
                    client: element.clientWidth
                },
                // check overflow.x/y because iPad (and possibly other tablets) don't dislay scrollbars
                scrollableX: function() {
                    return (overflow.x || overflow.isRoot) && this.width.scroll > this.width.client;
                },
                scrollableY: function() {
                    return (overflow.y || overflow.isRoot) && this.height.scroll > this.height.client;
                }
            };
            return direction.y && size.scrollableY() || direction.x && size.scrollableX();
        }
    });
})(jQuery);